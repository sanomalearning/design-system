{
  "version": 3,
  "sources": ["../../../node_modules/@11ty/is-land/is-land.js"],
  "sourcesContent": ["const islandOnceCache = new Map();\n\nclass Island extends HTMLElement {\n  static tagName = \"is-land\";\n  static prefix = \"is-land--\";\n  static attr = {\n    autoInitType: \"autoinit\",\n    import: \"import\",\n    template: \"data-island\",\n    ready: \"ready\",\n    defer: \"defer-hydration\",\n  };\n\n  static fallback = {\n    \":not(:defined):not([defer-hydration])\": (readyPromise, node, prefix) => {\n      // remove from document to prevent web component init\n      let cloned = document.createElement(prefix + node.localName);\n      for(let attr of node.getAttributeNames()) {\n        cloned.setAttribute(attr, node.getAttribute(attr));\n      }\n\n      // Declarative Shadow DOM\n      let shadowroot = node.shadowRoot;\n      if(!shadowroot) {\n        // polyfill\n        let tmpl = node.querySelector(\":scope > template[shadowroot]\");\n        if(tmpl) {\n          shadowroot = node.attachShadow({ mode: \"open\" });\n          shadowroot.appendChild(tmpl.content.cloneNode(true));\n        }\n      }\n\n      // cheers to https://gist.github.com/developit/45c85e9be01e8c3f1a0ec073d600d01e\n      if(shadowroot) {\n        cloned.attachShadow({ mode: shadowroot.mode }).append(...shadowroot.childNodes);\n      }\n\n      // Keep the *same* child nodes, clicking on a details->summary child should keep the state of that child\n      cloned.append(...node.childNodes);\n      node.replaceWith(cloned);\n\n      return readyPromise.then(() => {\n        // restore children (not cloned), including declarative shadow dom nodes\n        if(cloned.shadowRoot) {\n          node.shadowRoot.append(...cloned.shadowRoot.childNodes);\n        }\n        node.append(...cloned.childNodes);\n        cloned.replaceWith(node);\n      });\n    }\n  };\n\n  static autoinit = {\n    \"petite-vue\": function(library) {\n      library.createApp().mount(this);\n    },\n    \"vue\": function(library) {\n      library.createApp().mount(this);\n    },\n    \"svelte\": function(mod) {\n      new mod.default({ target: this });\n    },\n    \"svelte-ssr\": function(mod) {\n      new mod.default({ target: this, hydrate: true });\n    },\n    \"preact\": function(mod) {\n      mod.default(this);\n    }\n  }\n\n  constructor() {\n    super();\n\n    // Internal promises\n    this.ready = new Promise(resolve => {\n      this.readyResolve = resolve;\n    });\n  }\n\n  // <is-land> parent nodes (that *have* island conditions)\n  static getParents(el, stopAt = false) {\n    let nodes = [];\n    while(el) {\n      if(el.matches && el.matches(Island.tagName)) {\n        if(stopAt && el === stopAt) {\n          break;\n        }\n\n        if(Conditions.hasConditions(el)) {\n          nodes.push(el);\n        }\n      }\n      el = el.parentNode;\n    }\n    return nodes;\n  }\n\n  static async ready(el) {\n    let parents = Island.getParents(el);\n    if(parents.length === 0) {\n      return;\n    }\n\n    let imports = await Promise.all(parents.map(el => el.wait()));\n    // return innermost module import\n    if(imports.length) {\n      return imports[0];\n    }\n  }\n\n  forceFallback() {\n    if(window.Island) {\n      Object.assign(Island.fallback, window.Island.fallback);\n    }\n\n    for(let selector in Island.fallback) {\n      // Reverse here as a cheap way to get the deepest nodes first\n      let components = Array.from(this.querySelectorAll(selector)).reverse();\n\n      // with thanks to https://gist.github.com/cowboy/938767\n      for(let node of components) {\n        // must be connected, must not be an island\n        if(!node.isConnected || node.localName === Island.tagName) {\n          continue;\n        }\n\n        let p = Island.ready(node);\n        Island.fallback[selector](p, node, Island.prefix);\n      }\n    }\n  }\n\n  wait() {\n    return this.ready;\n  }\n\n  async connectedCallback() {\n    // Only use fallback content with loading conditions\n    if(Conditions.hasConditions(this)) {\n      // Keep fallback content without initializing the components\n      this.forceFallback();\n    }\n\n    await this.hydrate();\n  }\n\n  getTemplates() {\n    return this.querySelectorAll(`template[${Island.attr.template}]`);\n  }\n\n  replaceTemplates(templates) {\n    // replace <template> with the live content\n    for(let node of templates) {\n      // if the template is nested inside another child <is-land> inside, skip\n      if(Island.getParents(node, this).length > 0) {\n        continue;\n      }\n\n      let value = node.getAttribute(Island.attr.template);\n      // get rid of the rest of the content on the island\n      if(value === \"replace\") {\n        let children = Array.from(this.childNodes);\n        for(let child of children) {\n          this.removeChild(child);\n        }\n        this.appendChild(node.content);\n        break;\n      } else {\n        let html = node.innerHTML;\n        if(value === \"once\" && html) {\n          if(islandOnceCache.has(html)) {\n            node.remove();\n            return;\n          }\n\n          islandOnceCache.set(html, true);\n        }\n\n        node.replaceWith(node.content);\n      }\n    }\n  }\n\n  async hydrate() {\n    let conditions = [];\n    if(this.parentNode) {\n      // wait for all parents before hydrating\n      conditions.push(Island.ready(this.parentNode));\n    }\n\n    let attrs = Conditions.getConditions(this);\n    for(let condition in attrs) {\n      if(Conditions.map[condition]) {\n        conditions.push(Conditions.map[condition](attrs[condition], this));\n      }\n    }\n\n    // Loading conditions must finish before dependencies are loaded\n    await Promise.all(conditions);\n\n    this.replaceTemplates(this.getTemplates());\n\n    let mod;\n    // [dependency=\"my-component-code.js\"]\n    let importScript = this.getAttribute(Island.attr.import);\n    if(importScript) {\n      // we could resolve import maps here manually but you\u2019d still have to use the full URL in your script\u2019s import anyway\n      mod = await import(importScript);\n    }\n\n    if(mod) {\n      // Use `import=\"\"` for when import maps are available e.g. `import=\"petite-vue\"`\n      let fn = Island.autoinit[this.getAttribute(Island.attr.autoInitType) || importScript];\n\n      if(fn) {\n        await fn.call(this, mod);\n      }\n    }\n\n    this.readyResolve({\n      // import: mod\n    });\n\n    this.setAttribute(Island.attr.ready, \"\");\n\n    // Remove [defer-hydration]\n    this.querySelectorAll(`[${Island.attr.defer}]`).forEach(node => node.removeAttribute(Island.attr.defer));\n  }\n}\n\nclass Conditions {\n  static map = {\n    visible: Conditions.visible,\n    idle: Conditions.idle,\n    interaction: Conditions.interaction,\n    media: Conditions.media,\n    \"save-data\": Conditions.saveData,\n  };\n\n  static hasConditions(node) {\n    return Object.keys(Conditions.getConditions(node)).length > 0;\n  }\n\n  static getConditions(node) {\n    let map = {};\n    for(let key of Object.keys(Conditions.map)) {\n      if(node.hasAttribute(`on:${key}`)) {\n        map[key] = node.getAttribute(`on:${key}`);\n      }\n    }\n\n    return map;\n  }\n\n  static visible(noop, el) {\n    if(!('IntersectionObserver' in window)) {\n      // runs immediately\n      return;\n    }\n\n    return new Promise(resolve => {\n      let observer = new IntersectionObserver(entries => {\n        let [entry] = entries;\n        if(entry.isIntersecting) {\n          observer.unobserve(entry.target);\n          resolve();\n        }\n      });\n\n      observer.observe(el);\n    });\n  }\n\n  // TODO make sure this runs after all of the conditions have finished, otherwise it will\n  // finish way before the other lazy loaded promises and will be the same as a noop when\n  // on:interaction or on:visible finishes much later\n  static idle() {\n    let onload = new Promise(resolve => {\n      if(document.readyState !== \"complete\") {\n        window.addEventListener(\"load\", () => resolve(), { once: true });\n      } else {\n        resolve();\n      }\n    });\n\n    if(!(\"requestIdleCallback\" in window)) {\n      // run immediately\n      return onload;\n    }\n\n    // both idle and onload\n    return Promise.all([\n      new Promise(resolve => {\n        requestIdleCallback(() => {\n          resolve();\n        });\n      }),\n      onload,\n    ]);\n  }\n\n  static interaction(eventOverrides, el) {\n    let events = [\"click\", \"touchstart\"];\n    // event overrides e.g. on:interaction=\"mouseenter\"\n    if(eventOverrides) {\n      events = (eventOverrides || \"\").split(\",\").map(entry => entry.trim());\n    }\n\n    return new Promise(resolve => {\n      function resolveFn(e) {\n        resolve();\n\n        // cleanup the other event handlers\n        for(let name of events) {\n          el.removeEventListener(name, resolveFn);\n        }\n      }\n\n      for(let name of events) {\n        el.addEventListener(name, resolveFn, { once: true });\n      }\n    });\n  }\n\n  static media(query) {\n    let mm = {\n      matches: true\n    };\n\n    if(query && (\"matchMedia\" in window)) {\n      mm = window.matchMedia(query);\n    }\n\n    if(mm.matches) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      mm.addListener(e => {\n        if(e.matches) {\n          resolve();\n        }\n      });\n    });\n  }\n\n  static saveData(expects) {\n    // return early if API does not exist\n    if(!(\"connection\" in navigator) || navigator.connection.saveData === (expects !== \"false\")) {\n      return Promise.resolve();\n    }\n\n    // dangly promise\n    return new Promise(() => {});\n  }\n}\n\n// Should this auto define? Folks can redefine later using { component } export\nif(\"customElements\" in window) {\n  window.customElements.define(Island.tagName, Island);\n  window.Island = Island;\n}\n\nexport const component = Island;\n\nexport const ready = Island.ready;\n"],
  "mappings": "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",
  "names": ["el"]
}
